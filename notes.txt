rules: 
    Any live cell with fewer than two live neighbours dies, as if by underpopulation.
    Any live cell with two or three live neighbours lives on to the next generation.
    Any live cell with more than three live neighbours dies, as if by overpopulation.
    Any dead cell with exactly three live neighbours becomes a live cell, as if by reproduction.


(Cairo Makie - static so GL better)

observables, listener - will be called whenever observable change

mit kompletni seznam bodu - mit tam aj ty mrtve 
(mozna pocitat osa odzadu, misto rotace)
heatmap
glider gun
periodicke okraje 
    - halo - udelat navic okraje 
    - pouzit mod (abych zjistila, kde jsem - jestli jsem uz mimo bound, dostanu vzdycky cislo mezi 1 - n)
    - muzu pouzit posunuti indexu (OffsetArray - knihovna)
    
on bezi kazdy frame - udelat jeden krok simulace, muze byt libovolny pocet on (s)

(pojmenovane on muzu vypnout pomoci off)
minimalizovat globaly

axis - da mi vsechny platne indexy (bez zavislosti na typu?) + prekladac je rychlejsi, protoze vi, ze je to z axis takze ok 

neni potreba pouzivat observable? - staci jenom na levlu rozbrazovani
(ctrl + lomitko)

aktualne neni asi potreba observable board, stejne vytvarim novou array 

heatmap / image!

na zacatku namalovat zrovna puvodni matici (random) ne prazdne policka

( muzu menit jenom barvy na zaklade pozice)

muzu si jenom z matice vybrat body pro ktere mam true a predam je scatteru (vyzobnu pozice ktere mam true)

knihovna - offsetArrays 


NotebookLM.google 

zkusit chat bot na zpetnou vazbu k mluveni :) - Gemini


1. Ta kopie halo je v poradku, ale to pole se zbytecne vytvari znova. 
    Pointa je, ze to offset array muze byt to s tema hlavnima datama, kde na platnejch indexech najdes stavu boardu, a do tech okraju si aktualizujes halo, kdyz delas dalsi iteraci.
    
2. Tech observables mas myslim skutecne zbytecne hodne. Sice to neni formalni problem, dokud spravne pouzivas [], ale je tam nejake overhead a hlavne se to blbe pise. Observables muzou zustat jenom kolem ploteni, jinak staci plain arrays. 
V make_figure by sis napriklad udelala board_plot = Observable(b.board)a to potom predala do heatmap.
    Aktualizace plotu je potom proste board_plot[] = b.board.

? Trochu slozitejsi strukturni vec, ale nastinim a pak kdyztak doresime.  Ve strukture Board by bylo lepsi nemit zadny observables, je to stav simulovanyho systemu, o zobrazeni a podobne nic nevi a vedet nemusi. Veci jako isrunningmuzou ve skutecnosti byt v make_figure, ty veci vytvoreny pomoci on jsou tzv. closures a zlvadnou to. Ale do toho se ted nema smysl zanorovat vic.

4. A posledni vec, ten simulaci krok je porad strasne slozitej, muze byt o dost jednodussi. Vubec nemusis delat to vlastni krokovani, staci reagovat na kazdej tick zobrazeni (frekvence je podle nastavenyho FPS, defaultne 30).

Zhruba takhle, osekanej priklad z myho kodu:
 
 
Plain Text
    on(figure.scene.events.tick) do event
        running[] || return
        # take one simulation step
        metropolis!(ising, 1, T[])
        # update the plot observable
        σ_plot[] = ising.σ
    end
A potom uz ti staci butonkem nebo klavesou menit stav toho running. Delay neni potreba, tick se emituje pri kazdym prekresleni.

Cela ta slozitost v gol neni potreba. Jestli chces pocitat snimky nebo neco dalsiho, provedes to v tomcallbacku, co ukazuju.


na delay: nenasla jsem lepsi reseni nez sleep(), 
tick.delta_time vypada ze je interni soucasti, pocitani s tim mi prislo jeste horsi ? - zeptat se Ondry

zkusit halo bez ghost cells